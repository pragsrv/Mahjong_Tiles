<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mahjong Tiles</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #2d5016, #4a7c59);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .game-container {
            max-width: 1200px;
            width: 100%;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .controls {
            margin-bottom: 20px;
        }

        button {
            padding: 10px 20px;
            margin: 0 10px;
            background: linear-gradient(45deg, #8B4513, #A0522D);
            color: white;
            border: 2px solid #654321;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        button:hover {
            background: linear-gradient(45deg, #A0522D, #CD853F);
            transform: translateY(-2px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .game-board {
            position: relative;
            margin: 20px auto;
            perspective: 1000px;
            width: 1000px;
            height: 700px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .tile {
            position: absolute;
            width: 60px;
            height: 80px;
            background: linear-gradient(135deg, #f5f5dc, #e6e6fa);
            border: 2px solid #8b7355;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: #2c1810;
            box-shadow: 2px 2px 6px rgba(0,0,0,0.3);
            user-select: none;
        }

        .tile:hover {
            background: linear-gradient(135deg, #fff8dc, #f0f8ff);
            transform: translateY(-3px);
            box-shadow: 3px 3px 10px rgba(0,0,0,0.4);
        }

        .tile.selected {
            background: linear-gradient(135deg, #ffff99, #ffffe0);
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
        }

        .tile.matched {
            opacity: 0;
            transform: scale(0.8);
            pointer-events: none;
        }

        .tile.blocked {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 20px;
            font-size: 18px;
        }

        .message {
            margin-top: 20px;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .win-message {
            color: #ffd700;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .tile.hint {
            animation: glow 1s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { box-shadow: 2px 2px 6px rgba(0,0,0,0.3); }
            to { box-shadow: 0 0 20px rgba(255, 255, 0, 0.8); }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>🀄 Microsoft Mahjong Solitaire 🀄</h1>
        
        <div class="controls">
            <button onclick="newGame()">New Game</button>
            <button onclick="shuffle()">Shuffle</button>
            <button onclick="hint()">Hint</button>
            <button onclick="undo()" id="undoBtn" disabled>Undo</button>
        </div>

        <div class="game-board" id="gameBoard"></div>

        <div class="stats">
            <div>Tiles Remaining: <span id="tilesRemaining">144</span></div>
            <div>Matches: <span id="matches">0</span></div>
            <div>Time: <span id="timer">00:00</span></div>
        </div>

        <div id="message" class="message"></div>
    </div>

    <script>
        // Mahjong tile symbols
        const tileSymbols = {
            // Dots/Circles
            '1dot': '🀙', '2dot': '🀚', '3dot': '🀛', '4dot': '🀜', '5dot': '🀝', '6dot': '🀞', '7dot': '🀟', '8dot': '🀠', '9dot': '🀡',
            // Bamboo/Sticks
            '1bam': '🀐', '2bam': '🀑', '3bam': '🀒', '4bam': '🀓', '5bam': '🀔', '6bam': '🀕', '7bam': '🀖', '8bam': '🀗', '9bam': '🀘',
            // Characters/Numbers
            '1char': '🀇', '2char': '🀈', '3char': '🀉', '4char': '🀊', '5char': '🀋', '6char': '🀌', '7char': '🀍', '8char': '🀎', '9char': '🀏',
            // Winds
            'east': '🀀', 'south': '🀁', 'west': '🀂', 'north': '🀃',
            // Dragons
            'red': '🀄', 'green': '🀅', 'white': '🀆',
            // Flowers and Seasons (simplified)
            'flower1': '🌸', 'flower2': '🌺', 'flower3': '🌻', 'flower4': '🌹',
            'season1': '🌿', 'season2': '🍂', 'season3': '❄️', 'season4': '🌱'
        };

        let gameState = {
            tiles: [],
            selectedTile: null,
            matches: 0,
            tilesRemaining: 144,
            gameWon: false,
            history: [],
            startTime: Date.now(),
            timerInterval: null
        };

        // Turtle layout pattern (simplified version)
        const turtleLayout = [
            // Layer 0 (bottom)
            [2,0,0], [3,0,0], [4,0,0], [5,0,0], [6,0,0], [7,0,0], [8,0,0], [9,0,0], [10,0,0], [11,0,0], [12,0,0], [13,0,0],
            [2,1,0], [3,1,0], [4,1,0], [5,1,0], [6,1,0], [7,1,0], [8,1,0], [9,1,0], [10,1,0], [11,1,0], [12,1,0], [13,1,0],
            [1,2,0], [2,2,0], [3,2,0], [4,2,0], [5,2,0], [6,2,0], [7,2,0], [8,2,0], [9,2,0], [10,2,0], [11,2,0], [12,2,0], [13,2,0], [14,2,0],
            [0,3,0], [1,3,0], [2,3,0], [3,3,0], [4,3,0], [5,3,0], [6,3,0], [7,3,0], [8,3,0], [9,3,0], [10,3,0], [11,3,0], [12,3,0], [13,3,0], [14,3,0], [15,3,0],
            [0,4,0], [1,4,0], [2,4,0], [3,4,0], [4,4,0], [5,4,0], [6,4,0], [7,4,0], [8,4,0], [9,4,0], [10,4,0], [11,4,0], [12,4,0], [13,4,0], [14,4,0], [15,4,0],
            [0,5,0], [1,5,0], [2,5,0], [3,5,0], [4,5,0], [5,5,0], [6,5,0], [7,5,0], [8,5,0], [9,5,0], [10,5,0], [11,5,0], [12,5,0], [13,5,0], [14,5,0], [15,5,0],
            [1,6,0], [2,6,0], [3,6,0], [4,6,0], [5,6,0], [6,6,0], [7,6,0], [8,6,0], [9,6,0], [10,6,0], [11,6,0], [12,6,0], [13,6,0], [14,6,0],
            [2,7,0], [3,7,0], [4,7,0], [5,7,0], [6,7,0], [7,7,0], [8,7,0], [9,7,0], [10,7,0], [11,7,0], [12,7,0], [13,7,0],
            // Layer 1
            [3,1,1], [4,1,1], [5,1,1], [6,1,1], [7,1,1], [8,1,1], [9,1,1], [10,1,1], [11,1,1], [12,1,1],
            [3,2,1], [4,2,1], [5,2,1], [6,2,1], [7,2,1], [8,2,1], [9,2,1], [10,2,1], [11,2,1], [12,2,1],
            [3,3,1], [4,3,1], [5,3,1], [6,3,1], [7,3,1], [8,3,1], [9,3,1], [10,3,1], [11,3,1], [12,3,1],
            [3,4,1], [4,4,1], [5,4,1], [6,4,1], [7,4,1], [8,4,1], [9,4,1], [10,4,1], [11,4,1], [12,4,1],
            [3,5,1], [4,5,1], [5,5,1], [6,5,1], [7,5,1], [8,5,1], [9,5,1], [10,5,1], [11,5,1], [12,5,1],
            [3,6,1], [4,6,1], [5,6,1], [6,6,1], [7,6,1], [8,6,1], [9,6,1], [10,6,1], [11,6,1], [12,6,1],
            // Layer 2
            [4,2,2], [5,2,2], [6,2,2], [7,2,2], [8,2,2], [9,2,2], [10,2,2], [11,2,2],
            [4,3,2], [5,3,2], [6,3,2], [7,3,2], [8,3,2], [9,3,2], [10,3,2], [11,3,2],
            [4,4,2], [5,4,2], [6,4,2], [7,4,2], [8,4,2], [9,4,2], [10,4,2], [11,4,2],
            [4,5,2], [5,5,2], [6,5,2], [7,5,2], [8,5,2], [9,5,2], [10,5,2], [11,5,2],
            // Layer 3
            [5,3,3], [6,3,3], [7,3,3], [8,3,3], [9,3,3], [10,3,3],
            [5,4,3], [6,4,3], [7,4,3], [8,4,3], [9,4,3], [10,4,3],
            // Layer 4 (top)
            [7,3,4], [8,3,4], [7,4,4], [8,4,4]
        ];

        function createTileSet() {
            const tiles = [];
            const tileTypes = Object.keys(tileSymbols);
            
            // Create 4 of each tile type (standard mahjong set)
            for (let i = 0; i < tileTypes.length; i++) {
                for (let j = 0; j < 4; j++) {
                    tiles.push({
                        type: tileTypes[i],
                        symbol: tileSymbols[tileTypes[i]],
                        id: `${tileTypes[i]}_${j}`
                    });
                }
            }
            
            return shuffleArray(tiles);
        }

        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function initializeGame() {
            const tileSet = createTileSet();
            gameState.tiles = [];
            
            // Place tiles according to turtle layout
            turtleLayout.forEach((position, index) => {
                if (index < tileSet.length) {
                    const tile = {
                        ...tileSet[index],
                        x: position[0],
                        y: position[1],
                        z: position[2],
                        element: null,
                        matched: false
                    };
                    gameState.tiles.push(tile);
                }
            });
            
            gameState.selectedTile = null;
            gameState.matches = 0;
            gameState.tilesRemaining = gameState.tiles.length;
            gameState.gameWon = false;
            gameState.history = [];
            gameState.startTime = Date.now();
            
            renderGame();
            startTimer();
            updateStats();
        }

        function renderGame() {
            const board = document.getElementById('gameBoard');
            board.innerHTML = '';
            
            // Calculate offset to center the layout
            const minX = Math.min(...gameState.tiles.map(t => t.x));
            const maxX = Math.max(...gameState.tiles.map(t => t.x));
            const minY = Math.min(...gameState.tiles.map(t => t.y));
            const maxY = Math.max(...gameState.tiles.map(t => t.y));
            
            const offsetX = (board.offsetWidth - (maxX - minX + 1) * 60) / 2;
            const offsetY = (board.offsetHeight - (maxY - minY + 1) * 60) / 2;
            
            gameState.tiles.forEach(tile => {
                if (!tile.matched) {
                    const tileElement = document.createElement('div');
                    tileElement.className = 'tile';
                    tileElement.textContent = tile.symbol;
                    tileElement.style.left = `${offsetX + tile.x * 60 + tile.z * 5}px`;
                    tileElement.style.top = `${offsetY + tile.y * 60 + tile.z * 5}px`;
                    tileElement.style.zIndex = tile.z * 100 + tile.y * 10 + tile.x;
                    tileElement.onclick = () => selectTile(tile);
                    
                    tile.element = tileElement;
                    
                    // Check if tile is blocked
                    if (isTileBlocked(tile)) {
                        tileElement.classList.add('blocked');
                        tileElement.onclick = null;
                    }
                    
                    board.appendChild(tileElement);
                }
            });
        }

        function isTileBlocked(tile) {
            // Check if tile has free sides (left or right)
            const hasLeftNeighbor = gameState.tiles.some(t => 
                !t.matched && t.x === tile.x - 1 && t.y === tile.y && t.z === tile.z
            );
            const hasRightNeighbor = gameState.tiles.some(t => 
                !t.matched && t.x === tile.x + 1 && t.y === tile.y && t.z === tile.z
            );
            
            // Check if tile is covered by tiles above
            const isCovered = gameState.tiles.some(t => 
                !t.matched && t.z === tile.z + 1 && 
                Math.abs(t.x - tile.x) <= 1 && Math.abs(t.y - tile.y) <= 1
            );
            
            return (hasLeftNeighbor && hasRightNeighbor) || isCovered;
        }

        function selectTile(tile) {
            if (tile.matched || isTileBlocked(tile) || gameState.gameWon) return;
            
            if (gameState.selectedTile === tile) {
                // Deselect tile
                tile.element.classList.remove('selected');
                gameState.selectedTile = null;
            } else if (gameState.selectedTile === null) {
                // Select first tile
                tile.element.classList.add('selected');
                gameState.selectedTile = tile;
            } else {
                // Try to match tiles
                if (tilesMatch(gameState.selectedTile, tile)) {
                    // Match found
                    matchTiles(gameState.selectedTile, tile);
                } else {
                    // No match, select new tile
                    gameState.selectedTile.element.classList.remove('selected');
                    tile.element.classList.add('selected');
                    gameState.selectedTile = tile;
                }
            }
        }

        function tilesMatch(tile1, tile2) {
            return tile1.type === tile2.type;
        }

        function matchTiles(tile1, tile2) {
            // Save state for undo
            gameState.history.push({
                tile1: {...tile1},
                tile2: {...tile2}
            });
            
            // Mark tiles as matched
            tile1.matched = true;
            tile2.matched = true;
            tile1.element.classList.add('matched');
            tile2.element.classList.add('matched');
            
            gameState.selectedTile = null;
            gameState.matches++;
            gameState.tilesRemaining -= 2;
            
            setTimeout(() => {
                renderGame();
                updateStats();
                checkWin();
            }, 300);
            
            document.getElementById('undoBtn').disabled = false;
        }

        function updateStats() {
            document.getElementById('tilesRemaining').textContent = gameState.tilesRemaining;
            document.getElementById('matches').textContent = gameState.matches;
        }

        function checkWin() {
            if (gameState.tilesRemaining === 0) {
                gameState.gameWon = true;
                clearInterval(gameState.timerInterval);
                document.getElementById('message').innerHTML = 
                    '<div class="win-message">🎉 Congratulations! You won! 🎉</div>';
            } else if (!hasValidMoves()) {
                document.getElementById('message').innerHTML = 
                    '<div>No more moves available. Try shuffling or start a new game.</div>';
            } else {
                document.getElementById('message').innerHTML = '';
            }
        }

        function hasValidMoves() {
            const freeTiles = gameState.tiles.filter(tile => !tile.matched && !isTileBlocked(tile));
            for (let i = 0; i < freeTiles.length; i++) {
                for (let j = i + 1; j < freeTiles.length; j++) {
                    if (tilesMatch(freeTiles[i], freeTiles[j])) {
                        return true;
                    }
                }
            }
            return false;
        }

        function newGame() {
            clearInterval(gameState.timerInterval);
            document.getElementById('message').innerHTML = '';
            document.getElementById('undoBtn').disabled = true;
            initializeGame();
        }

        function shuffle() {
            if (gameState.gameWon) return;
            
            const unmatchedTiles = gameState.tiles.filter(tile => !tile.matched);
            const shuffledTypes = shuffleArray(unmatchedTiles.map(tile => ({
                type: tile.type,
                symbol: tile.symbol
            })));
            
            unmatchedTiles.forEach((tile, index) => {
                tile.type = shuffledTypes[index].type;
                tile.symbol = shuffledTypes[index].symbol;
            });
            
            renderGame();
            document.getElementById('message').innerHTML = '';
        }

        function hint() {
            if (gameState.gameWon) return;
            
            // Clear previous hints
            document.querySelectorAll('.tile.hint').forEach(tile => {
                tile.classList.remove('hint');
            });
            
            const freeTiles = gameState.tiles.filter(tile => !tile.matched && !isTileBlocked(tile));
            for (let i = 0; i < freeTiles.length; i++) {
                for (let j = i + 1; j < freeTiles.length; j++) {
                    if (tilesMatch(freeTiles[i], freeTiles[j])) {
                        freeTiles[i].element.classList.add('hint');
                        freeTiles[j].element.classList.add('hint');
                        
                        setTimeout(() => {
                            freeTiles[i].element.classList.remove('hint');
                            freeTiles[j].element.classList.remove('hint');
                        }, 3000);
                        
                        return;
                    }
                }
            }
            
            document.getElementById('message').innerHTML = 'No hints available!';
            setTimeout(() => {
                document.getElementById('message').innerHTML = '';
            }, 2000);
        }

        function undo() {
            if (gameState.history.length === 0) return;
            
            const lastMove = gameState.history.pop();
            
            // Find the tiles and restore them
            const tile1 = gameState.tiles.find(t => t.id === lastMove.tile1.id);
            const tile2 = gameState.tiles.find(t => t.id === lastMove.tile2.id);
            
            if (tile1 && tile2) {
                tile1.matched = false;
                tile2.matched = false;
                gameState.matches--;
                gameState.tilesRemaining += 2;
                
                renderGame();
                updateStats();
                checkWin();
            }
            
            if (gameState.history.length === 0) {
                document.getElementById('undoBtn').disabled = true;
            }
        }

        function startTimer() {
            gameState.timerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('timer').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        }

        // Initialize the game when page loads
        window.onload = function() {
            initializeGame();
        };
    </script>
</body>
</html>